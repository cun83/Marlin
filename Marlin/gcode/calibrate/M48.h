/**
 * Marlin 3D Printer Firmware
 * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
 *
 * Based on Sprinter and grbl.
 * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * M48: Z probe repeatability measurement function.
 *
 * Usage:
 *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
 *     P = Number of sampled points (4-50, default 10)
 *     X = Sample X position
 *     Y = Sample Y position
 *     V = Verbose level (0-4, default=1)
 *     E = Engage Z probe for each reading
 *     L = Number of legs of movement before probe
 *     S = Schizoid (Or Star if you prefer)
 *
 * This function assumes the bed has been homed.  Specifically, that a G28 command
 * as been issued prior to invoking the M48 Z probe repeatability measurement function.
 * Any information generated by a prior G29 Bed leveling command will be lost and need to be
 * regenerated.
 */
inline void gcode_M48() {

  if (axis_unhomed_error(true, true, true)) return;

  int8_t verbose_level = code_seen('V') ? code_value_byte() : 1;
  if (verbose_level < 0 || verbose_level > 4) {
    SERIAL_PROTOCOLLNPGM("?Verbose Level not plausible (0-4).");
    return;
  }

  if (verbose_level > 0)
    SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability test");

  int8_t n_samples = code_seen('P') ? code_value_byte() : 10;
  if (n_samples < 4 || n_samples > 50) {
    SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
    return;
  }

  float  X_current = current_position[X_AXIS],
         Y_current = current_position[Y_AXIS];

  bool stow_probe_after_each = code_seen('E');

  float X_probe_location = code_seen('X') ? code_value_axis_units(X_AXIS) : X_current + X_PROBE_OFFSET_FROM_EXTRUDER;
  #if DISABLED(DELTA)
    if (X_probe_location < LOGICAL_X_POSITION(MIN_PROBE_X) || X_probe_location > LOGICAL_X_POSITION(MAX_PROBE_X)) {
      out_of_range_error(PSTR("X"));
      return;
    }
  #endif

  float Y_probe_location = code_seen('Y') ? code_value_axis_units(Y_AXIS) : Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER;
  #if DISABLED(DELTA)
    if (Y_probe_location < LOGICAL_Y_POSITION(MIN_PROBE_Y) || Y_probe_location > LOGICAL_Y_POSITION(MAX_PROBE_Y)) {
      out_of_range_error(PSTR("Y"));
      return;
    }
  #else
    if (HYPOT(RAW_X_POSITION(X_probe_location), RAW_Y_POSITION(Y_probe_location)) > DELTA_PROBEABLE_RADIUS) {
      SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
      return;
    }
  #endif

  bool seen_L = code_seen('L');
  uint8_t n_legs = seen_L ? code_value_byte() : 0;
  if (n_legs > 15) {
    SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
    return;
  }
  if (n_legs == 1) n_legs = 2;

  bool schizoid_flag = code_seen('S');
  if (schizoid_flag && !seen_L) n_legs = 7;

  /**
   * Now get everything to the specified probe point So we can safely do a
   * probe to get us close to the bed.  If the Z-Axis is far from the bed,
   * we don't want to use that as a starting point for each probe.
   */
  if (verbose_level > 2)
    SERIAL_PROTOCOLLNPGM("Positioning the probe...");

  #if ENABLED(DELTA)
    // we don't do bed level correction in M48 because we want the raw data when we probe
    reset_bed_level();
  #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
    // we don't do bed level correction in M48 because we want the raw data when we probe
    planner.bed_level_matrix.set_to_identity();
  #endif

  setup_for_endstop_or_probe_move();

  // Move to the first point, deploy, and probe
  probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);

  randomSeed(millis());

  double mean = 0, sigma = 0, sample_set[n_samples];
  for (uint8_t n = 0; n < n_samples; n++) {
    if (n_legs) {
      int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
      float angle = random(0.0, 360.0),
            radius = random(
              #if ENABLED(DELTA)
                DELTA_PROBEABLE_RADIUS / 8, DELTA_PROBEABLE_RADIUS / 3
              #else
                5, X_MAX_LENGTH / 8
              #endif
            );

      if (verbose_level > 3) {
        SERIAL_ECHOPAIR("Starting radius: ", radius);
        SERIAL_ECHOPAIR("   angle: ", angle);
        SERIAL_ECHOPGM(" Direction: ");
        if (dir > 0) SERIAL_ECHOPGM("Counter-");
        SERIAL_ECHOLNPGM("Clockwise");
      }

      for (uint8_t l = 0; l < n_legs - 1; l++) {
        double delta_angle;

        if (schizoid_flag)
          // The points of a 5 point star are 72 degrees apart.  We need to
          // skip a point and go to the next one on the star.
          delta_angle = dir * 2.0 * 72.0;

        else
          // If we do this line, we are just trying to move further
          // around the circle.
          delta_angle = dir * (float) random(25, 45);

        angle += delta_angle;

        while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
          angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
        while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
          angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.

        X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
        Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;

        #if DISABLED(DELTA)
          X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
          Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
        #else
          // If we have gone out too far, we can do a simple fix and scale the numbers
          // back in closer to the origin.
          while (HYPOT(X_current, Y_current) > DELTA_PROBEABLE_RADIUS) {
            X_current /= 1.25;
            Y_current /= 1.25;
            if (verbose_level > 3) {
              SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
              SERIAL_ECHOPAIR(", ", Y_current);
              SERIAL_EOL;
            }
          }
        #endif
        if (verbose_level > 3) {
          SERIAL_PROTOCOLPGM("Going to:");
          SERIAL_ECHOPAIR(" X", X_current);
          SERIAL_ECHOPAIR(" Y", Y_current);
          SERIAL_ECHOPAIR(" Z", current_position[Z_AXIS]);
          SERIAL_EOL;
        }
        do_blocking_move_to_xy(X_current, Y_current);
      } // n_legs loop
    } // n_legs

    // Probe a single point
    sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);

    /**
     * Get the current mean for the data points we have so far
     */
    double sum = 0.0;
    for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
    mean = sum / (n + 1);

    /**
     * Now, use that mean to calculate the standard deviation for the
     * data points we have so far
     */
    sum = 0.0;
    for (uint8_t j = 0; j <= n; j++)
      sum += sq(sample_set[j] - mean);

    sigma = sqrt(sum / (n + 1));
    if (verbose_level > 0) {
      if (verbose_level > 1) {
        SERIAL_PROTOCOL(n + 1);
        SERIAL_PROTOCOLPGM(" of ");
        SERIAL_PROTOCOL((int)n_samples);
        SERIAL_PROTOCOLPGM("   z: ");
        SERIAL_PROTOCOL_F(current_position[Z_AXIS], 6);
        if (verbose_level > 2) {
          SERIAL_PROTOCOLPGM(" mean: ");
          SERIAL_PROTOCOL_F(mean, 6);
          SERIAL_PROTOCOLPGM("   sigma: ");
          SERIAL_PROTOCOL_F(sigma, 6);
        }
      }
      SERIAL_EOL;
    }

  } // End of probe loop

  if (STOW_PROBE()) return;

  if (verbose_level > 0) {
    SERIAL_PROTOCOLPGM("Mean: ");
    SERIAL_PROTOCOL_F(mean, 6);
    SERIAL_EOL;
  }

  SERIAL_PROTOCOLPGM("Standard Deviation: ");
  SERIAL_PROTOCOL_F(sigma, 6);
  SERIAL_EOL; SERIAL_EOL;

  clean_up_after_endstop_or_probe_move();

  report_current_position();
}
